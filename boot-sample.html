<!DOCTYPE html>
<!-- from http://bl.ocks.org/mbostock/4339083
and http://bl.ocks.org/mbostock/4063550

!-->
<meta charset="utf-8">
<style>

.node circle {
  fill: #fff;
  stroke: steelblue;
  stroke-width: 1.5px;
}

.node {
  font: 10px sans-serif;
}

.link {
  fill: none;
  stroke: #ccc;
  stroke-width: 1.5px;
}
#tree1par {
  vertical-align: top;
  float: left;
}
#tree2par {
  vertical-align: center;
  float: left;
}
#tree3par {
  vertical-align: bottom;
  float: left;
}
#histpar {
  vertical-align: top;
  float: right;
}
</style>
<body>
<script src="d3/d3.v3.min.js"></script>
<script src="jquery/jquery.v2.min.js"></script>
<table>
  <tr>
    <td>
      <input name="boot" type="button" value="Bootstrap" onclick="bootstrap()" />
    </td>
    <td><div id="src"/></td>
    <td><div id="hist"/></td>
  </tr>
  <tr><td />
          <td><span id="abBootText"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <span id="acBootText"></span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
              <span id="adBootText"></span>
      </td>
      <td />
   </tr>
</table>
<script>
var MAT_WIDTH = 200;
var MAT_HEIGHT = 120;
var SPACE = 60;
var FIG_HEIGHT = 2*MAT_HEIGHT + SPACE;
var NUM_CHAR = 10;
var OFFSET = MAT_WIDTH / NUM_CHAR;
var COL_WIDTH = OFFSET;
var TEXT_X = COL_WIDTH/2;
var TEXT_Y = MAT_HEIGHT/4;
var TEXT_Y_OFF = TEXT_Y/2;
var NUM_OVERLAID = 1; /* 1 + NUM_CHAR; */
var LOWER_Y = MAT_HEIGHT + SPACE;
var margin = {top: 10, right: 10, bottom: 35, left: 75}
var src_svg = d3.select('#src').append('svg')
    .attr({'width': MAT_WIDTH + margin.left + margin.right,
           'height': FIG_HEIGHT + margin.bottom + margin.top, })
    .style('background', 'white');
var src_data = [];
var i = 0;
var ind = 0;
var pat = ['AAAA', 'CCTT', 'CCCC', 'AAAA', 'GGAA', 'CGCG', 'TTTT', 'GAAG', 'CTTC', 'TTGG'];
var typ = [    0,      1,      0,      0,      1,      3,     0,       2,      2,      1];
var ab = 0;
var ac = 0;
var ad = 0;
var nc = 0
for (nc = 0 ; nc < NUM_CHAR; ++nc) {
    var cp = pat[nc];
    var ct = typ[nc]
    for (i = 0; i < NUM_OVERLAID; ++i) {
        src_data[ind] = {'x': margin.left + COL_WIDTH*nc,
                         'y': 0,
                         'value': ct,
                         'site': cp,
                         'oind': i};
        if (ct == 1) {
            ad += 1;
        } else if (ct == 2) {
            ab += 1;
        } else if (ct == 3) {
            ac += 1;
        }

        ind += 1;
    }
}

var color = d3.scale.threshold()
    .domain([.5, 1.5, 2.5, 3.5])
    .range(['#BBBBBB', '#FF0000', '#00FF00', '#6666FF'])

var do_init = function (src_data) {
    var bar = src_svg.selectAll("g")
        .data(src_data);
    bar.enter().append("g");
    bar.append("rect")
        .attr("x", function(d) {return d.x})
        .attr("y", function(d) {return d.y})
        .attr("width", OFFSET)
        .attr("height", MAT_HEIGHT)
        .attr("fill", function(d) {return color(d.value)});
    var j;
    for (j = 0 ; j < 4; ++j) {
        var k = j;
        bar.append("text")
            .attr("x", function(d) {return d.x + TEXT_X;})
            .attr("y", function(d) {return d.y + k*TEXT_Y + TEXT_Y_OFF;})
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .text(function(d) {return d.site[k];})
    }
    bar.exit().remove();
    return bar;
}
var pseudo_rep_x = 0;

var do_update = function (src_data) {
    var bar = src_svg.selectAll("g")
        .data(src_data);
    var cp = margin.left + pseudo_rep_x;
    var nb = bar
        .enter().append("g")
            .attr("transform", function(d, i) {return "translate(" + d.x +", " + d.y+ ")";});
    pseudo_rep_x += COL_WIDTH * nb.length;
    nb.append("rect")
         .attr("width", OFFSET)
         .attr("height", MAT_HEIGHT)
         .attr("fill", function(d) {return color(d.value)});
    var j;
    for (j = 0 ; j < 4; ++j) {
        var k = j;
        nb.append("text")
            .attr("x", function(d) {return TEXT_X;})
            .attr("y", function(d) {return k*TEXT_Y + TEXT_Y_OFF;})
            .attr("dy", ".35em")
            .attr("text-anchor", "middle")
            .text(function(d) {return d.site[k];})
    }
    nb.transition()
        .duration(750)
        .attr("transform", function(d, i) {return "translate(" + cp +", " + LOWER_Y + ")";});
}
do_init(src_data);
var LABEL_Y = 5
var LABEL_X = 20;
var labels = ["Human", "Chimp", "Gorilla", "Orang"];
var ul;
for (ul = 0; ul < 2; ++ul) {
    for (i = 0 ; i < 4; ++i) {
        src_svg.append("text").attr("x", LABEL_X).attr("y", LABEL_Y + i*TEXT_Y + TEXT_Y_OFF).text(labels[i]);
    }
    LABEL_Y += LOWER_Y;
}
var prev_points = [];
var num_sampled = 0;
var curr_points = [0, 0, 0];
var norm_curr_points = [];
var bootstrap = function() {
    curr_points = [0, 0, 0];
    norm_curr_points = [];
    src_data = src_data.slice(0, NUM_CHAR);
    do_init(src_data);
    num_sampled = 0;
    pseudo_rep_x = 0
    do_boot_draw();
};
var millisecond_sleep = 500;
var num_boot_reps = 0;
var nAB = 0;
var nAC = 0;
var nAD = 0;

var do_boot_draw = function() {
    var sel_ind = Math.floor(Math.random()*NUM_CHAR);
    src_data[src_data.length] = src_data[sel_ind];
    num_sampled += 1;
    var v = src_data[sel_ind].value;
    if (v == 1) {
        curr_points[2] += 1;
    } else if (v == 2) {
        curr_points[0] += 1;
    } else if (v == 3) {
        curr_points[1] += 1;
    }
    update_bary_for_boot();
    do_update(src_data);
    if (num_sampled < NUM_CHAR) {
        setTimeout(function() {do_boot_draw();}, millisecond_sleep);
    } else {
        prev_points[prev_points.length] = {'counts': norm_curr_points};
        if (prev_points.length == 1) {
            prev_points[prev_points.length] = prev_points[0];
        }

        num_boot_reps += 1;
        if (norm_curr_points[0] > norm_curr_points[1]) {
            if (norm_curr_points[0] > norm_curr_points[2]) {
                nAD += 1;
            } else if (norm_curr_points[2] > norm_curr_points[0]) {
                nAC += 1;
            }
        } else if (norm_curr_points[1] > norm_curr_points[0]) {
            if (norm_curr_points[1] > norm_curr_points[2]) {
                nAB += 1;
            } else if (norm_curr_points[2] > norm_curr_points[1]) {
                nAC += 1;
            }
        } else if (norm_curr_points[2] > norm_curr_points[0]) {
            if (norm_curr_points[1] > norm_curr_points[2]) {
                nAC += 1;
            } else if (norm_curr_points[2] > norm_curr_points[1]) {
                nAD += 1;
            }
        }
        abBootText.text('C+G ' + (100*nAB/num_boot_reps).toFixed(1) + '%');
        acBootText.text('H+G' + (100*nAC/num_boot_reps).toFixed(1) + '%');
        adBootText.text('H+C' + (100*nAD/num_boot_reps).toFixed(1) + '%');
    }
};
/* ############################################################### */
var BARY_WIDTH = 300;
var BARY_HEIGHT = 220;
var i;
var radius = 3;
var hist_svg = d3.select('#hist').append('svg')
    .attr({'width': BARY_WIDTH,
           'height': BARY_HEIGHT, })
    .style('background', 'white');

var TREE1COLOR = '#0E3';
var TREEPREF1COLOR = '#EFD';
var TREE2COLOR = '#00F';
var TREEPREF2COLOR = '#EEF';
var TREE3COLOR = '#F00';
var TREEPREF3COLOR = '#FEE';
var prob_vec = [[1/3, 1/3, 1/3],
                [1/2, 1/4, 1/4],
                [1/4, 1/2, 1/4],
                [1/4, 1/4, 1/2]
                ] ;
var BARY_MARGIN = 10;
var BARY_LEFT_MARGIN = 40;
var BARY_RIGHT_MARGIN = 10;
var BARY_X_SCALER = BARY_HEIGHT - BARY_RIGHT_MARGIN - BARY_LEFT_MARGIN;
var BARY_BASE = BARY_HEIGHT - BARY_MARGIN;
var BARY_TOP = 20;
var BARY_Y_SCALER = BARY_BASE - BARY_TOP;
if (BARY_Y_SCALER > BARY_X_SCALER) {
  BARY_Y_SCALER = BARY_X_SCALER;
} else {
  BARY_X_SCALER = BARY_Y_SCALER;
}
var barycentric2xy = function(probs) {
  var y = BARY_BASE - BARY_Y_SCALER*probs[0];
  var x = BARY_LEFT_MARGIN + BARY_X_SCALER*(probs[0] + probs[1]*2.0)/1.7320508075688767;
  return {'x':x, 'y':y};
}
var barY = function(data, i) {
  return barycentric2xy(data).y;
};
var barX = function(data, i) {
  return barycentric2xy(data).x;
};

var lower_left_tri = barycentric2xy([0, 0])
var lower_right_tri = barycentric2xy([0,1])
var top_tri = barycentric2xy([1, 0])
var mid_left_tri = barycentric2xy([0.5, 0])
var mid_right_tri = barycentric2xy([0.5, 0.5])
var mid_bottom_tri = barycentric2xy([0, 0.5])
var mid_point_tri = barycentric2xy([1/3, 1/3])
var t1pathSpec = 'M ' + mid_point_tri.x + ',' + mid_point_tri.y + 'L ' + mid_left_tri.x + ',' + mid_left_tri.y +  'L ' + top_tri.x + ',' + top_tri.y + 'L ' + mid_right_tri.x + ',' + mid_right_tri.y + ' Z' ;
var t2pathSpec = 'M ' + mid_point_tri.x + ',' + mid_point_tri.y + 'L ' + mid_right_tri.x + ',' + mid_right_tri.y +  'L ' + lower_right_tri.x + ',' + lower_right_tri.y + 'L ' + mid_bottom_tri.x + ',' + mid_bottom_tri.y + ' Z' ;
var t3pathSpec = 'M ' + mid_point_tri.x + ',' + mid_point_tri.y + 'L ' + mid_left_tri.x + ',' + mid_left_tri.y +  'L ' + lower_left_tri.x + ',' + lower_left_tri.y + 'L ' + mid_bottom_tri.x + ',' + mid_bottom_tri.y + ' Z' ;
hist_svg.append('path')
    .attr({'stroke': TREEPREF1COLOR,
           'fill': TREEPREF1COLOR,
           'd': t1pathSpec});
hist_svg.append('path')
    .attr({'stroke': TREEPREF2COLOR,
           'fill': TREEPREF2COLOR,
           'd': t2pathSpec});
hist_svg.append('path')
    .attr({'stroke': TREEPREF3COLOR,
           'fill': TREEPREF3COLOR,
           'd': t3pathSpec});
hist_svg.append('text')
    .attr({'x': lower_left_tri.x - 33,
           'y': lower_left_tri.y + 6,
           'stroke': TREE3COLOR,
           'fill': TREE3COLOR})
    .text("H+C");
hist_svg.append('text')
    .attr({'x': lower_right_tri.x + 2,
           'y': lower_right_tri.y + 6,
           'stroke': TREE2COLOR,
           'fill': TREE2COLOR})
    .text("H+G");
hist_svg.append('text')
    .attr({'x': top_tri.x - 15,
           'y': top_tri.y - 6,
           'stroke': TREE1COLOR,
           'fill': TREE1COLOR})
    .text("C+G");
hist_svg.append('line')
    .attr({'x1': mid_left_tri.x,
           'y1': mid_left_tri.y,
           'x2': mid_point_tri.x,
           'y2': mid_point_tri.y,
           'stroke': '#000',
           'stroke-width': 1});
hist_svg.append('line')
    .attr({'x1': mid_right_tri.x,
           'y1': mid_right_tri.y,
           'x2': mid_point_tri.x,
           'y2': mid_point_tri.y,
           'stroke': '#000',
           'stroke-width': 1});
hist_svg.append('line')
    .attr({'x1': mid_bottom_tri.x,
           'y1': mid_bottom_tri.y,
           'x2': mid_point_tri.x,
           'y2': mid_point_tri.y,
           'stroke': '#000',
           'stroke-width': 1});
hist_svg.append('line')
    .attr({'x1': lower_left_tri.x,
           'y1': lower_left_tri.y,
           'x2': lower_right_tri.x,
           'y2': lower_right_tri.y,
           'stroke': '#000',
           'stroke-width': 2});
hist_svg.append('line')
    .attr({'x1': lower_left_tri.x,
           'y1': lower_left_tri.y,
           'x2': top_tri.x,
           'y2': top_tri.y,
           'stroke': '#000',
           'stroke-width': 2});
hist_svg.append('line')
    .attr({'x1': top_tri.x,
           'y1': top_tri.y,
           'x2': lower_right_tri.x,
           'y2': lower_right_tri.y,
           'stroke': '#000',
           'stroke-width': 2});

var bary_points = hist_svg
  .append('circle')
    .attr({'cx': mid_point_tri.x,
           'cy': mid_point_tri.y,
           'r': radius,
           'fill': '#000',
           'stroke': '#000',
           'id': 'origpoint'});
var abBootText = d3.select("#abBootText");
var acBootText = d3.select("#acBootText");
var adBootText = d3.select("#adBootText");
function update_bary() {
    var denom = ab + ac + ad;
    var p_arr = [1/3, 1/3, 1/3];
    if (denom > 0) {
      p_arr = [ab/denom, ac/denom, ad/denom];
    }
    coord_vec = barycentric2xy(p_arr);
    hist_svg.selectAll("circle")
      .data([])
      .exit().remove();
    hist_svg.append('circle')
    .attr({'cx': coord_vec.x,
           'cy': coord_vec.y,
           'r': radius,
           'fill': '#FFF',
           'stroke': '#000',
           'id': 'origpoint'});
    abBootText.text('C+G ???%');
    acBootText.text('H+G ???%');
    adBootText.text('H+C ???%');
}

var count_vec_radius = function(data, i) {
  if (i > 0) {
    return 2;
  }
  return 0;
}
var count_vec_to_x = function(v) {
  var c = v.counts;
  var denom = c[0] + c[1] + c[2];
  var p_arr = [c[0]/denom, c[1]/denom, c[2]/denom];
  var coord_vec = barycentric2xy(p_arr);
  return coord_vec.x;
}
var count_vec_to_y = function(v) {
  var c = v.counts;
  var denom = c[0] + c[1] + c[2];
  var p_arr = [c[0]/denom, c[1]/denom, c[2]/denom];
  var coord_vec = barycentric2xy(p_arr);
  return coord_vec.y;
}
function bary_bootstrap() {
    var denom = ab + ac + ad;
    var p_arr = [1/3, 1/3, 1/3];
    if (denom > 1) {
      p_arr = [ab/denom, ac/denom, ad/denom];
    }
    var num_boot_reps = 100;
    var i;
    var counts = [ab, ac, ad];
    var v = [{'counts': counts}];
    var nAB = 0;
    var nAC = 0;
    var nAD = 0;
    for (i=1; i < 1 + num_boot_reps; ++i) {
      var resc = bootstrap_resample(counts);
      if (resc[0] > resc[1]) {
        if (resc[0] > resc[2]) {
          nAB += 1;
        }
      }
      if (resc[1] > resc[0]) {
        if (resc[1] > resc[2]) {
          nAC += 1;
        }
      }
      if (resc[2] > resc[1]) {
        if (resc[2] > resc[0]) {
          nAD += 1;
        }
      }
      v[i] = {'counts': resc};
    }
}

var update_bary_for_boot = function (p_arr) {
    var curr_denom = curr_points[0] + curr_points[1] + curr_points[2];
    if (curr_denom == 0) {
        norm_curr_points = [1, 1, 1];
    } else {
        norm_curr_points = [curr_points[0], curr_points[1], curr_points[2]];
    }
    hist_svg.selectAll("circle")
      .data([])
      .exit().remove();
    hist_svg.selectAll("circle")
      .data([{'counts': norm_curr_points}])
      .enter().append('circle')
      .attr({'cx': count_vec_to_x,
             'cy': count_vec_to_y,
             'fill':'#FF0',
             'stroke': '#000',
             'r': 3,
             'class': '.bootpoint'});

    hist_svg.selectAll("circle")
      .data(prev_points)
      .enter().append('circle')
      .attr({'cx': count_vec_to_x,
             'cy': count_vec_to_y,
             'fill':'#000',
             'r': count_vec_radius,
             'class': '.bootpoint'});
    var denom = ab + ac + ad;
    var p_arr = [1/3, 1/3, 1/3];
    if (denom > 0) {
      p_arr = [ab/denom, ac/denom, ad/denom];
    }
    coord_vec = barycentric2xy(p_arr);
    hist_svg.append('circle')
    .attr({'cx': coord_vec.x,
           'cy': coord_vec.y,
           'r': radius,
           'fill': '#FFF',
           'stroke': '#000',
           'id': 'origpoint'});
}
update_bary();
</script>
